---
layout: homework
title: "Assignment #8"
---
<style>
.hl {
	background-color: yellow;
}
img {
    border: 1px solid #000;
}

.warning {
    background-color: yellow;
    color: #aa1122;
    font-weight: bold;
}

.hidden {
    display: none;
}

.hintButton {
    color: #7788ff;
    cursor: pointer;
}
</style>
<script>
document.addEventListener('DOMContentLoaded', hideHints);

function hideHints(evt) {
    document.querySelectorAll('.hint').forEach((ele, i) => {
        const div = document.createElement('div');
        div.id = 'hint' + i + 'Button';
        ele.id = 'hint' + i;
        ele.classList.add('hidden');
        div.addEventListener('click', onClick);
        div.textContent = 'Show Hint';
        div.className = 'hintButton';
        ele.parentNode.insertBefore(div, ele);
    });

}

function onClick(evt) {
    const hintId = this.id.replace('Button', '');
    const hint = document.getElementById(hintId);
    hint.classList.toggle('hidden');
    this.textContent = this.textConent === 'Show Hint' ? 'Hide Hint' : 'Show Hint';
}
</script>

# Assignment #8 - Due Monday, April 26th at 11pm


In this homework, you'll:

1. Use conditionals, date and string functions, and
2. Create views, functions, and indexes
3. Connect to a PostgreSQL server by using SQLAlchemy

## Part 1: 

### Overview

### Import

## Part 2: Eateries (SQLAlchemy, Date Arithmetic, Functions, Indexes)

### Preparation

Download the __JSON__ file containing a directory of eateries in NYC parks from 2018 from [the data's homepage at NYC Open Data](
https://data.cityofnewyork.us/Recreation/Directory-of-Eateries/8792-ebcp)

* read [through the data dictionary](https://www.nycgovparks.org/bigapps/desc/DPR_Eateries_001.txt) to determine the fields
* view the JSON file in a text editor and note the property names

### DDL

In `src/create_eateries.sql`, write SQL statements to create a table that stores the data from the json file

* start your .sql file with `DROP TABLE IF EXISTS eatery`
* add a `CREATE TABLE eatery` statement...
* accommodate every field in the JSON file
* limit the field types to `text` and `date`
* add a surrogate key, `eatery_id`, as the primary key 
* run your sql in `src/create_eateries.sql` by using any method you like (for example, psql with `\i` or using DataGrip or PgAdmin)

### Python Prep

In `src/db.py`, create functions and a class. The functions will be for reading a config file (that contains your database credentials) and creating sessions and connections.

* create a function called `generate_dsn` that takes one argument: a single string, the path to a config file
	* it should return a string in the format of:
	* `postgresql://{yourusername}:{yourpassword}@localhost/{database}`
* create a function called `get_session` that takes one argument: a single string, the dsn (the data source name, or the string used to connect to your database)
	* it should return a SQLAlchemy session, [see the slides on sessionmaker and session](../slides/py-db/sql-alchemy-relationships.html#13), and check out [the example code](../slides/py-db/sql-alchemy-relationships.html#23) (ignore `declarative base` for now)
* create a class that represents an eatery
	* [see the slides on creating classes that map to tables](../slides/py-db/sql-alchemy-relationships.html#5); read up to the slide on [columns](../slides/py-db/sql-alchemy-relationships.html#11)
	* name the class `Eatery`
	* it should include all fields from your create statement, with the appropriate SQLAlchemy type
	* the surrogate key, `report_id`, can be defined as an `Integer`
	* here's an example: [imports](../slides/py-db/sql-alchemy-relationships.html#22) (please bring in `Date` rather than `DateTime`), and a [class definition](../slides/py-db/sql-alchemy-relationships.html#24)

### Adding Eateries to the Database

In `src/load_eateries.py`, read and parse the json file. Please use relative paths, as if the file were running from the `src` directory.

* `import` your `db` module
* create a dsn using one of your module's functions
* create a `session` using one of your module's functions
* loop through your json data, and instantiate a new eatery using your class... and save each eatery into a list
* use the `session` method, [`add_all`](https://docs.sqlalchemy.org/en/14/orm/session_api.html#sqlalchemy.orm.Session.add_all) to add all instances
* make sure to `commit` afterwards
* run your Python script and verify that data has been loaded

### Eatery Queries

In `src/eatery_queries.sql`, write queries based on the questions below.

* write the query or queries you would use to answer the questions
* in a comment below the query, write the first few lines of output of your query

Questions

1. What is the average permit duration? Which eatery has the longest permit?
	* write a function to calculate the permit duration in years as `numeric` by using a `CREATE OR REPLACE FUNCTION` statement [see the sample sql file](../sql/design/functions-views.sql), no rounding required
	* use the function in a query to calculate the average duration of permits
	* use the function in a query to display the name and permit number of the eatery with the longest permit __without using LIMIT__ (that is, use a subquery)
2. What is the count of eateries per year based on permit start date?
	* show the year and number of eateries in the dataset for that year, based on start date
	* sort by the year ascending
3. What are the names and eatery types of every eatery in the dataset?
	* break apart the data into two separate tables:
		* instead of a single `eatery_table`, move out `type_name` into its own table
		* call this new table `eatery_type`
		* it should only have two columns: a surrogate key, `eatery_type_id`... and `name`
		* the original `eatery` table should reference theh rows in this new table by using a foreign key
	* write a `CREATE` statement that creates the `eatery_type` table
	* using an `INSERT` statement with a subquery, add rows to the `eatery_type` table based on the distinct values of the `type_name` column in the `eatery` table
	* use an `ALTER` table statement to add a new foreign key column to `eatery` called `eatery_type_id` that references the primary key of the `eatery_type` table ([see the Examples in the postgres docs](https://www.postgresql.org/docs/current/sql-altertable.html#id-1.9.3.35.8))
	* write an `UPDATE` statement to populate the foreign key in `eatery`, but do this using an `UPDATE` with a `FROM` clause... that essentially results in a join ([see the notes section in the postgres docs](https://www.postgresql.org/docs/current/sql-update.html#id-1.9.3.182.8) [as well as a stackoverlow answer](https://stackoverflow.com/a/7869611))
		```
UPDATE table1 as t
SET col = other_col
FROM table2          -- join with this table
WHERE fk = pk
```
	* use an `ALTER TABLE` statement to remove the `type_name` column from `eatery` so that the type only lives in the referenced table, `eatery_type`... and only the fk exists in `eatery`
	* finally, write a `SELECT` statement to test out your two tables; show the name and type of every eatery by using a join
4. Cart or not?
	```	
select eatery.eatery_id, eatery.name, permit_number, case when eatery_type.name ilike '%cart' then 'Cart' else eatery_type.name end from eatery inner join eatery_type on eatery.eatery_type_id = eatery_type.eatery_type_id;
```
5. Can this be easier?
	```
create view eatery_report as select eatery.eatery_id, eatery.name, permit_number, case when eatery_type.name ilike '%cart' then 'Cart' else eatery_type.name end as t from eatery inner join eatery_type on eatery.eatery_type_id = eatery_type.eatery_type_id;
select t, count(*) from eatery_report group by t;
```
6. Can this be faster?
	* `explain analyze select * from eatery where name = 'Pushcart';`
	* `create index on eatery(name);`
	* `explain analyze select * from eatery where name = 'Pushcart';`:w
